#!/usr/bin/env python3
# Script for sorrying OCF user accounts rewritten in python3
import argparse
import datetime
import grp
import os
import shutil
import subprocess
import sys

import ocflib.account.manage
import ocflib.account.search
import ocflib.account.utils
import ocflib.misc.mail

reason_path = '/opt/share/utils/staff/acct/sorry/'
sorry_shell = '/opt/share/utils/bin/sorried'


def find_sorry_file(file_path):
    # Own sorry file
    if (os.path.isfile(file_path)):
        return file_path

    # Default sorry files
    if (os.path.isfile(reason_path + file_path)):
        return reason_path + file_path

    raise FileNotFoundError("FATAL: Sorry file \"{}\" does not exist. Exiting.".format(file_path))


def sorry_user(username, sorry_file):
    attributes = ocflib.account.search.user_attrs(username)
    if attributes is None:
        raise ValueError('User not found.')

    rootstaffer = real_user()
    kerberos_credentials(rootstaffer)

    user_dir = attributes['homeDirectory']

    # Workaround for ldap3 1.x.x machines
    if isinstance(user_dir, list):
        user_dir = user_dir[0]

    print('Copying sorry file and making .oldshell file')

    if not (os.path.isfile(user_dir + '/.oldshell')):
        oldshell = attributes['loginShell']
        # Workaround for ldap3 1.x.x machines
        if isinstance(oldshell, list):
            oldshell = user_dir[0]

        oldshell_file = open(user_dir + '/.oldshell', 'w')
        oldshell_file.write(oldshell)
        oldshell_file.close()

    shutil.copy2(sorry_file, user_dir + '/.sorry')
    os.chmod(user_dir + '/.sorry', 0o400)
    shutil.chown(user_dir + '/.sorry', user=username, group='ocf')

    print("Changing user's shell to sorry shell")

    ocflib.infra.ldap.modify_ldap_entry(ocflib.account.utils.dn_for_username(username),
                                        {'loginShell': sorry_shell, 'gidNumber': grp.getgrnam('sorry').gr_gid})

    http_dir = '/services/http/users/{0}/{1}'.format(username[0], username)
    print('Changing permissions on httpdir to 000')
    if (os.path.isdir(http_dir)):
        os.chmod(http_dir, 0o000)

    print('Changing permissions on home directory to 500')
    os.chmod(user_dir, 0o500)

    # WTF is final system check for?
    # log(rootstaffer, username)
    send_log_mail(rootstaffer, username, open(reason_path, 'r').read())

    user_mail = get_user_real_mail(username)
    if user_mail:
        send_sorry_mail(user_mail, username, open(reason_path, 'r').read())
    kerberos_destroy()

# Returns the real user who is running this script


def real_user():
    if 'SUDO_USER' in os.environ and os.environ['SUDO_USER'] != 'root':
        return os.environ['SUDO_USER']
    else:
        print("The sorry.log is much more useful when it logs who you are rather than simply 'root'.")
        username = input('Please enter your username: ')
        return username


def kerberos_credentials(staff_name):
    if ('SORRY_KRB5CCNAME' in os.environ):
        print('SORRY_KRB5CCNAME set in environment. Assuming this file contains current admin credentials.')
        os.environ['KRB5CCNAME'] = os.environ['SORRY_KRB5CCNAME']
    else:
        print('Your are {0}.'.format(staff_name))
        if (subprocess.call([shutil.which('kinit'), '{0}/admin'.format(staff_name)]) != 0):
            raise OSError('Kinit failed, bailing out!')
        else:
            print('Kinit complete.')


def kerberos_destroy():
    return subprocess.call(['kdestroy'])


def get_user_real_mail(username):
    email = str(subprocess.run([shutil.which('ldapsearch'),
                                'uid={0}'.format(username), 'mail'], stdout=subprocess.PIPE).stdout)
    email = email[email.find('\\nmail') + 8:]
    email = email[:email.find('\\n\\n')]
    return email


def log(root_staffer, sorried_user):
    with open('/opt/acct/sorry.log', 'a') as log_file:
        # Date style matters...?
        log_file.write('{0} - {1} {2}'.format(str(datetime.datetime.now()), root_staffer, sorried_user))


def send_log_mail(root_staffer, sorried_user, reason):
    email_from = 'Open Computing Facility <sorry_log@ocf.berkeley.edu>'
    email_subject = '[OCF] Account disabled'
    email_body = '''
This is an automated email sent by sorry script. This is the log of a recent sorry operation:
Account "{0}" has been disabled by "{1}" for reason "{2}" on "{3}".
'''.format(sorried_user, root_staffer, reason, str(datetime.datetime.now()))
    ocflib.misc.mail.send_mail('root@ocf.berkeley.edu', email_subject, email_body, cc=None, sender=email_from)


def send_sorry_mail(sorried_user_email, username, reason):
    email_from = 'Open Computing Facility <help@ocf.berkeley.edu>'
    email_subject = '[OCF] Account disabled'
    email_body = '''
Hello,

Your OCF account has been disabled.

Your account name is: {0}

The reason your account has been disabled:
{1}

Feel free to reply to this message.
Please do not share your password with anyone or over email.

{2}
    '''.format(username, reason, ocflib.misc.mail.MAIL_SIGNATURE)
    ocflib.misc.mail.send_mail(sorried_user_email, email_subject, email_body, cc=None, sender=email_from)


def main():
    sorry_description = 'Sorry a user. \nStandard sorry reasons are: \n' + '\n'.join(
        [f for f in os.listdir(reason_path) if
         os.path.isfile(os.path.join(reason_path, f))]) + '\nBut you can also pass in your own file.'
    parser = argparse.ArgumentParser(usage='%(prog)s sorriedUser sorryReason',
                                     formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=sorry_description)
    parser.add_argument('sorriedUser', metavar='sorriedUser', help='Username of sorried user')
    parser.add_argument('sorryReason', metavar='sorriedReason', help='Reason for the user to be sorried')

    if (len(sys.argv) != 3):
        parser.print_help()
        return 1

    if os.getuid() != 0:
        raise PermissionError('You must be root to run this.')

    args = parser.parse_args()
    file_path = find_sorry_file(args.sorryReason)
    print('Sorry file {}.'.format(file_path))

    sorry_user(args.sorriedUser, file_path)
    print('NOW RUN note -u {0} reason. NOW'.format(args.sorriedUser))


if __name__ == '__main__':
    sys.exit(main())
